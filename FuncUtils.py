import argparse
import inspect
import re
import warnings
from types import FunctionType
from typing import List, Dict


def get_description(func: FunctionType) -> str:
    """
    Returns the description part of the documentation of the function.
    :param func: The function to retrieve documentation from.
    :return: The documentation of the function.
    """
    docstring = inspect.getdoc(func)
    doc_end = docstring.find(':')
    if doc_end == -1:
        return docstring
    return docstring[:doc_end].strip()


def get_parameters(func: FunctionType) -> List[Dict]:
    """
    Yields the parameters of the function given.
    For each parameter, returns a dictionary with 'name', 'type' and 'description'.
    :param func: The function to yield parameters for.
    :return: A dictionary with data regarding the parameter.
    """
    signature = inspect.signature(func)
    docstring = inspect.getdoc(func)
    for param in signature.parameters.values():
        result = re.compile(f':param {param.name}:\s*(?P<desc>.*)\s*:param').search(
            docstring.replace('\n', ''))
        if result is None:
            result = re.compile(f':param {param.name}:\s*(?P<desc>.*)\s*:return').search(
                docstring.replace('\n', ''))
        yield {
            'name': param.name,
            'type': param.annotation,
            'description': result.groupdict()['desc'] if result is not None else ''
        }


def make_kebab_case(string: str) -> str:
    """
    Converts a string to kebab case, great for CLI arguments.
    :param string: The string to convert.
    :return: A kebab case formatted string
    """
    return string.lower().replace(' ', '-').replace('_', '-')


def generate_parser(func: FunctionType, skip_help=False) -> argparse.ArgumentParser:
    """
    Creates a parser using argparse and the functions signature / docstring.
    :param func: The function to generate the argparser for.
    :return: An argument parser for the function.
    """
    docstring = get_description(func)
    parameters = [param for param in get_parameters(func)]
    arg_parser = argparse.ArgumentParser(description=docstring, epilog='Automatically generated by AutoCli')
    for param in parameters:
        settings = {
            'type': param['type']
        }
        if not skip_help:
            settings['help'] = param['description']
        else:
            settings['add_help'] = False
        arg_parser.add_argument(make_kebab_case(param['name']), **settings)
    return arg_parser


def generate_action_settings(func: FunctionType):
    parameters = [param for param in get_parameters(func)]
    for param in parameters:
        settings = dict(type=param['type'], help=param['description'])
        if param['type'] is bool:
            param['name'] = f'--{param["name"]}'
            settings['action'] = 'store_true'
            settings.pop('type')
        yield param['name'], settings


def generate_parser_definitions(func: FunctionType):
    return make_kebab_case(func.__name__), dict(description=get_description(func),
                                                epilog='Automatically generated by AutoCli')


def validate_parameters_in_docstring(func: FunctionType, supress_warnings=False):
    signature = inspect.signature(func)
    docstring = inspect.getdoc(func)
    for param in signature.parameters.values():
        result = re.compile(f':param {param.name}:\s*(?P<desc>.*)\s*:param').search(
            docstring.replace('\n', ''))
        if result is None:
            result = re.compile(f':param {param.name}:\s*(?P<desc>.*)\s*:return').search(
                docstring.replace('\n', ''))
            if result is None:
                warnings.warn(
                    f'Documentation not sufficient to parse description for parameter: "{param.name}" in function: "{func.__name__}".',
                    stacklevel=4)
        if param.annotation is inspect.Parameter.empty:
            return TypeError(
                f'No type annotation found for parameter: "{param.name}" in function: "{func.__name__}".')
